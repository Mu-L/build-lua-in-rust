<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Functions and API - Build a Lua Interpreter in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> Basic Compilation Principles</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> Value and Type</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> Let's Do It!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> Variables and Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> More Types</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> Local Variables</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> Variable Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> String Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> String Definition</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> Type Conversion</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> Input Type</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode and UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> Garbage Collection and Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> Table and ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> Table Definition</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> Table Construction</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc Concept</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc Rewrite</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> Table Read/Write and BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> Numerical Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> Unary Operations</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> Binary Operations</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> Integer and Float</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> Control Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if Statement</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif and else Branches</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while and break Statements</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat and continue Statements</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> numerical-for Statement</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto Statement</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> Logical and Relational Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> Logical Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> Logical Operations in Evalue</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> Relational Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> Relational Operations in Evalue</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> Definition and Call</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> Return Value</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html" class="active"><strong aria-hidden="true">8.4.</strong> Rust Functions and API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> Tail Call</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> Closure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue Escape and Closure</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> Escape from Block and goto</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust Closures</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> generic-for Statement</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> Environment _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">To Be Continued</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build a Lua Interpreter in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-function-and-apis"><a class="header" href="#rust-function-and-apis">Rust Function and APIs</a></h1>
<p>The previous three sections of this chapter introduce the functions defined in Lua, and this section introduces the functions defined in Rust. For the sake of simplicity, these two types of functions are called &quot;Lua functions&quot; and &quot;Rust functions&quot; respectively.</p>
<p>In fact, we have already been exposed to Rust functions. The <code>print()</code> that was supported in the <code>hello, world!</code> version of the first chapter is the Rust function. The interpreter at that time realized the definition and calling process of Rust functions. which is defined as follows:</p>
<pre><code class="language-rust  ignore">pub enum Value {
     RustFunction(fn (&amp;mut ExeState) -&gt; i32),</code></pre>
<p>Here is an example of the implementation code of <code>print()</code> function:</p>
<pre><code class="language-rust  ignore">fn lib_print(state: &amp;mut ExeState) -&gt; i32 {
     println!(&quot;{}&quot;, state.stack[state.base + 1]);
     0
}</code></pre>
<p>The calling method of the Rust function is also similar to the Lua function, and the Rust function is also called in the <code>Call</code> bytecode:</p>
<pre><code class="language-rust  ignore">     ByteCode::Call(func, _) =&gt; {
         let func = &amp;self. stack[func as usize];
         if let Value::Function(f) = func {
             f(self);</code></pre>
<p>The codes listed above are the functions of the implemented Rust functions, but they are only the most basic definitions and calls, and still lack parameters and return values. This section adds these two features to Rust functions.</p>
<p>One thing that needs to be explained is that in Lua code, the function call statement does not distinguish between Lua functions and Rust functions. In other words, the two types are not distinguished during the parsing phase. It is only in the virtual machine execution stage that the two types need to be treated differently. Therefore, what is described below in this section is all about the virtual machine stage.</p>
<h2 id="argument"><a class="header" href="#argument">Argument</a></h2>
<p>The arguments of Rust functions are also passed through the stack.</p>
<p>You can see that the implementation of the current <code>print()</code> function only supports one parameter, which is by directly reading the data on the stack: <code>state.stack[state.base + 1])</code>, where <code>self.base</code> is the function entry address , <code>+1</code> is the address immediately following, that is, the first parameter.</p>
<p>Now to support multiple parameters, it is necessary to inform the Rust function of the specific number of parameters. There are two options:</p>
<ul>
<li>Modify the Rust function prototype definition, add a parameter to express the number of parameters. This solution is simple to implement, but it is inconsistent with Lua's official C function prototype;</li>
<li>Adopt the variable parameter mechanism in the previous Lua function, that is, determine the number of parameters by the position of the top of the stack.</li>
</ul>
<p>We take the latter approach. This requires cleaning up possible temporary variables on the top of the stack before calling the function Rust:</p>
<pre><code class="language-rust  ignore">     ByteCode::Call(func, narg_plus) =&gt; {
         let func = &amp;self. stack[func as usize];
         if let Value::Function(f) = func {
             // narg_plus!=0, fixed parameters, need to clean up possible
             //               temporary variables on the top of the stack;
             // narg_plus==0, variable parameters, no need to clean up.
             if narg_plus != 0 {
                 self.stack.truncate(self.base + narg_plus as usize - 1);
             }

             f(self);</code></pre>
<p>After cleaning up the possible temporary variables at the top of the stack, in the Rust function, the specific number of parameters can be judged through the top of the stack: <code>state.stack.len() - state.base</code>; we can also directly read any argument, such as the Nth parameter: <code>state.stack[state.base + N])</code>. So modify the <code>print()</code> function as follows:</p>
<pre><code class="language-rust  ignore">fn lib_print(state: &amp;mut ExeState) -&gt; i32 {
     let narg = state.stack.len() - state.base; // number of arguments
     for i in 0 .. narg {
         if i != 0 {
             print!(&quot;\t&quot;);
         }
         print!(&quot;{}&quot;, state.stack[state.base + i]); // print the i-th argument
     }
     println!(&quot;&quot;);
     0
}</code></pre>
<h2 id="return-value"><a class="header" href="#return-value">Return Value</a></h2>
<p>The return value of the Rust function is also passed through the stack. The Rust function puts the return value on the top of the stack before exiting, and returns the number, which is the function of the <code>i32</code> type return value of the Lua function prototype. This is the same mechanism as the Lua function introduced in the previous section. We only need to process the return value of the Rust function according to the return value of the Lua function introduced in the previous section when the <code>Call</code> bytecode is executed:</p>
<pre><code class="language-rust  ignore">     ByteCode::Call(func, narg_plus) =&gt; {
         let func = &amp;self. stack[func as usize];
         if let Value::Function(f) = func {
             if narg_plus != 0 {
                 self.stack.truncate(self.base + narg_plus as usize - 1);
             }

             // Return the number of return values of the Rust function,
             // which is consistent with the Lua function
             f(self) as usize</code></pre>
<p>Convert the return value of the Rust function <code>f()</code> from <code>i32</code> to <code>usize</code> type and return, indicating the number of return values. Here the type conversion from <code>i32</code> to <code>usize</code> feels bad, because the C function in the official Lua implementation returns a negative number to indicate failure. We have directly panicked on all errors so far. Subsequent chapters will deal with errors uniformly. When <code>Option&lt;usize&gt;</code> is used instead of <code>i32</code>, this garish conversion will be removed.</p>
<p>The previous <code>print()</code> function had no return value and returned <code>0</code>, so it did not reflect the feature of return value. Let's take another Lua standard library function <a href="https://www.lua.org/manual/5.4/manual.html#pdf-type"><code>type()</code></a> with a return value as an example. The function of this function is to return the type of the first parameter, and the type of the return value is a string, such as &quot;nil&quot;, &quot;string&quot;, &quot;number&quot; and so on.</p>
<pre><code class="language-rust  ignore">fn lib_type(state: &amp;mut ExeState) -&gt; i32 {
     let ty = state.stack[state.base + 1].ty(); // the type of the first parameter
     state.stack.push(ty); // Push the result onto the stack
     1 // Only 1 return value
}</code></pre>
<p>Among them, the <code>ty()</code> function is a new method for the <code>Value</code> type, which returns a description of the type, and the specific code is omitted here.</p>
<h2 id="rust-api"><a class="header" href="#rust-api">Rust API</a></h2>
<p>So far, the characteristics of the parameters and return values of Rust functions have been realized. However, the access and processing of arguments and return values above are too direct, and the ability of Rust functions is too strong, not only can access the parameters of the current function, but also can access the entire stack space, and even the entire <code>state</code> state. This is irrational and dangerous. It is necessary to restrict the access of Rust functions to <code>state</code>, including the entire stack, which requires the limited ability of Rust functions to access <code>state</code> through the API. We have come to a new world: the Rust API, of course called the <a href="https://www.lua.org/manual/5.4/manual.html#4">C API</a> in the official Lua implementation.</p>
<p>The Rust API is an API provided by the Lua interpreter for Rust functions (the Lua library implemented by Rust). Its roles are as follows:</p>
<pre><code>     +------------------+
     |     Lua code     |
     +---+----------+---+
         |          |
         |  +-------V----------+
         |  | Standard Library |
         |  |    (Rust)        |
         |  +-------+----------+
         |          |Rust API
         |          |
+--------V----------V--------+
| Lua Virtual Machine (Rust) |
+----------------------------+
</code></pre>
<p>There are 3 functional requirements in the Rust function in the above section, all of which should be fulfilled by the API:</p>
<ul>
<li>Read the actual number of arguments;</li>
<li>read specified argument;</li>
<li>create return value</li>
</ul>
<p>These three requirements are described in turn below. The first is the function of reading the actual number of arguments, which corresponds to the <a href="https://www.lua.org/manual/5.4/manual.html#lua_gettop"><code>lua_gettop()</code></a> API in the official implementation of Lua. For this we provide <code>get_top()</code> API:</p>
<pre><code class="language-rust  ignore">impl&lt;'a&gt; ExeState {
     // Return to the top of the stack, that is, the number of parameters
     pub fn get_top(&amp;self) -&gt; usize {
         self.stack.len() - self.base
     }</code></pre>
<p>Although the <code>get_top()</code> function is also a method of the <code>ExeState</code> structure, it is provided as an API for external calls. The methods before <code>ExeState</code> (such as <code>execute()</code>, <code>get_stack()</code>, etc.) are all internal methods for virtual machine execution calls. In order to distinguish these two types of methods, we add an <code>impl</code> block to the <code>ExeState</code> structure to implement the API alone to increase readability. It's just that Rust does not allow the method of implementing the structure in different files, so it cannot be split into another file.</p>
<p>Then, the function of reading the specified parameters does not correspond to a function in the official Lua implementation, but a series of functions, such as <code>lua_toboolean()</code>, <code>lua_tolstring()</code>, etc., for different types. With the generic capabilities of the Rust language, we can provide only one API:</p>
<pre><code class="language-rust  ignore">     pub fn get&lt;T&gt;(&amp;'a self, i: isize) -&gt; T where T: From&lt;&amp;'a Value&gt; {
         let narg = self. get_top();
         if i &gt; 0 { // positive index, counting from self.base
             let i = i as usize;
             if i &gt; narg {
                 panic!(&quot;invalid index: {i} {narg}&quot;);
             }
             (&amp;self. stack[self. base + i - 1]). into()
         } else if i &lt; 0 { // Negative index, counting from the top of the stack
             let i = -i as usize;
             if i &gt; narg {
                 panic!(&quot;invalid index: -{i} {narg}&quot;);
             }
             (&amp;self.stack[self.stack.len() - i]).into()
         } else {
             panic!(&quot;invalid 0 index&quot;);
         }
     }</code></pre>
<p>You can see that this API also supports negative indexes, which means counting down from the top of the stack, which is the behavior of Lua's official API, and it is also a very common method of use. This also reflects the advantages of the API over direct access to the stack.</p>
<p>However, there is also a behavior that is inconsistent with the official API: when the index exceeds the stack range, the official will return <code>nil</code>, but here we panic directly. We will discuss this in detail later when we introduce error handling.</p>
<p>Based on the above two APIs, you can redo the <code>print()</code> function:</p>
<pre><code class="language-rust  ignore">fn lib_print(state: &amp;mut ExeState) -&gt; i32 {
     for i in 1 ..= state. get_top() {
         if i != 1 {
             print!(&quot;\t&quot;);
         }
         print!(&quot;{}&quot;, state.get::&lt;&amp;Value&gt;(i).to_string());
     }
     println!(&quot;&quot;);
     0
}</code></pre>
<p>Finally, let's look at the last function, creating the return value. Like the above API for reading arguments, there are also a series of functions in the official Lua implementation, such as <code>lua_pushboolean()</code>, <code>lua_pushlstring()</code>, etc. And here you can also add only one API with the help of generics:</p>
<pre><code class="language-rust  ignore">     pub fn push(&amp;mut self, v: impl Into&lt;Value&gt;) {
         self.stack.push(v.into());
     }</code></pre>
<p>Based on this API, <code>self.stack.push()</code> in the last line of <code>type()</code> function above can be changed to <code>self.push()</code>.</p>
<p>Although the implementation of the <code>print()</code> and <code>type()</code> functions has not changed significantly after replacing the API, the API provides a encapsulation for <code>ExeState</code>, which will gradually reflect the convenience in the process of gradually adding library functions safety.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-03.results.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch08-05.tail_call.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-03.results.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch08-05.tail_call.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
