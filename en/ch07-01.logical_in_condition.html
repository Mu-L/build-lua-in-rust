<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Logical Operations in Conditional Judgment - Build a Lua Interpreter in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> Basic Compilation Principles</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> Value and Type</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> Let's Do It!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> Variables and Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> More Types</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> Local Variables</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> Variable Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> String Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> String Definition</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> Type Conversion</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> Input Type</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode and UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> Garbage Collection and Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> Table and ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> Table Definition</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> Table Construction</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc Concept</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc Rewrite</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> Table Read/Write and BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> Numerical Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> Unary Operations</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> Binary Operations</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> Integer and Float</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> Control Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if Statement</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif and else Branches</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while and break Statements</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat and continue Statements</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> numerical-for Statement</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto Statement</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> Logical and Relational Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html" class="active"><strong aria-hidden="true">7.1.</strong> Logical Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> Logical Operations in Evalue</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> Relational Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> Relational Operations in Evalue</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> Definition and Call</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> Return Value</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust Functions and API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> Tail Call</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> Closure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue Escape and Closure</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> Escape from Block and goto</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust Closures</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> generic-for Statement</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> Environment _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">To Be Continued</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build a Lua Interpreter in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="logical-operations-in-conditional-judgment"><a class="header" href="#logical-operations-in-conditional-judgment">Logical Operations in Conditional Judgment</a></h1>
<p>Logical operations include 3: <code>and</code>, <code>or</code>, and <code>not</code>. The last <code>not</code> is a unary operation, which has been introduced in the previous section <a href="./ch05-01.unary_ops.html">Unary Operation</a>. This chapter only introduces the first two <code>and</code> and <code>or</code>.</p>
<p>Then why not introduce <code>and</code> and <code>or</code> in the previous <a href="./ch05-02.binary_ops.html">binary operation</a> section? Because of &quot;short circuit&quot;! In mainstream programming languages (such as C, Rust), logical operations are short-circuited. For example, for the AND operation, if the first operand is false, then there is no need (and cannot) to execute or check the second operand. For example, the statement <code>is_valid() and count()</code>, if the return value of <code>is_valid()</code> is false, then the subsequent <code>count()</code> cannot be executed. Therefore, the execution process of logical operations is: 1. First judge the left operand, 2. If it is false, exit, 3. Otherwise judge the right operand. While the execution process of the binary arithmetic operation is: 1. First find the left operand, 2. Then find the right operand, 3. Finally calculate. It can be seen that the flow of logical operations is different from that of arithmetic operations, so the previous methods cannot be applied.</p>
<p>Before introducing the logic operation in detail, let's look at two usage scenarios of logic operations:</p>
<ol>
<li>As a judgment condition, such as the judgment condition statement in if, while and other statements in the previous chapter, such as <code>if t and t.k then ... end</code>;</li>
<li>Evaluation, such as <code>print(v&gt;0 and v or -v)</code>.</li>
</ol>
<p>In fact, the first scenario can be regarded as a special case of the second scenario. For example, the above if statement example is equivalent to the following code:</p>
<pre><code class="language-lua">local tmp = t and t.k
if tmp then
     ...
end
</code></pre>
<p>It is to first evaluate the operation statement <code>t and t.k</code>, then put the value into a temporary variable, and finally judge whether the value is true or false to decide whether to jump. However, here we don't actually care whether the specific evaluation result is <code>t</code> or <code>t.k</code>, but only care about true or false, so we can save the temporary variable! As you can see below, the omission of temporary variables can save a bytecode, which is a great optimization. Since most applications of logical operations are in the first scenario, it is worthwhile to separate this scenario from the second general scenario for special optimization, by omitting temporary variables and directly judging whether to jump based on the evaluation result.</p>
<p>As the title of this section indicates, this section only introduces the first scenario; while the next section will introduce the second scenario.</p>
<h2 id="jump-rules"><a class="header" href="#jump-rules">Jump Rules</a></h2>
<p>The short-circuit characteristics of logic operations are introduced above. After each operand is judged, a jump may occur and the next operand is skipped. The bytecode corresponding to the logical operation is to jump according to each operand. Different operation combinations will lead to various jump combinations. Now it is necessary to summarize jump rules from various jump combinations, so as to be used as subsequent parsing rules. This is probably the most convoluted part of the whole interpreter.</p>
<p>The following uses the simplest <code>if</code> statement as the application scenario, and first looks at the most basic and and or operations. The following two figures are the jump schematic diagrams of <code>if A and B then ... end</code> and <code>if X or Y then ... end</code> respectively:</p>
<pre><code> A and B                      X or Y

+-------+                    +-------+
|   A   +-False-\    /--True-+   X   |
+---+---+       |    |       +---+---+
    |True       |    |           |False
    V           |    |           V
+-------+       |    |       +-------+
|   B   +-False&gt;+    |       |   Y   +-False-\
+---+---+       |    |       +---+---+      |
    |True       |    \----------&gt;|True      |
    V           |                V          |
  block         |              block        |
    |           |                |          |
    +&lt;----------/                +&lt;--------/
    V                            V
</code></pre>
<p>The left figure is the AND operation. The processing after the judgment of the two operands A and B is the same: if True, continue to execute; if False, jump to the end of the code block.</p>
<p>The figure on the right is the OR operation. The processing flow of the two operands is different. The processing of the first operand X is: False continues execution, and True jumps to the following code block to start. While the processing of the second operand Y is the same as the processing of A and B before.</p>
<p>However, just looking at these two examples is not able to sum up the general law. Also need to look at some complex:</p>
<pre><code>A and B and C               X or Y or Z                 (A and B) or Y               A and (X or Y)

+-------+                    +-------+                    +-------+                    +-------+
|   A   +-False-\    /--True-+   X   |                    |   A   |-False-\            |   A   +-False-\
+---+---+       |    |       +---+---+                    +---+---+       |            +---+---+       |
    |True       |    |           |False                       |True       |                |True       |
    V           |    |           V                            V           |                V           |
+-------+       |    |       +-------+                    +-------+       |            +-------+       |
|   B   +-False&gt;+    +&lt;-True-+   Y   |            /--True-+   B   |       |    /--True-+   X   |       |
+---+---+       |    |       +---+---+            |       +---+---+       |    |       +---+---+       |
    |True       |    |           |False           |      False|&lt;---------/     |           |False      |
    V           |    |           V                |           V                |           V           |
+-------+       |    |       +-------+            |       +-------+            |       +-------+       |
|   C   +-False&gt;+    |       |   Z   +-False-\    |       |   Y   +-False-\    |       |   Y   +-False&gt;+
+---+---+       |    |       +---+---+       |    |       +---+---+       |    |       +---+---+       |
    |True       |    \----------&gt;|True       |    \----------&gt;|True       |    \----------&gt;|True       |
    V           |                V           |                V           |                V           |
  block         |              block         |              block         |              block         |
    |           |                |           |                |           |                |           |
    +&lt;---------/                 +&lt;----------/                +&lt;---------/                 +&lt;---------/
    V                            V                            V                            V
</code></pre>
<p>According to these 4 diagrams, the following rules can be summarized (the specific steps of induction are omitted here. In practice, more examples may be needed to summarize, but too many examples are too bloated):</p>
<ul>
<li>
<p>The jump condition depends on the logical operator (that is, <code>and</code> or <code>or</code>) behind the statement (such as A, B, X, Y, etc. in the above example):</p>
<ul>
<li>
<p>If it is followed by <code>and</code> operation, False jumps and True continues execution. For example, A and B in the first picture are followed by and operations, so they are all False jumps.</p>
</li>
<li>
<p>If it is followed by an <code>or</code> operation, True jumps and False continues. For example, X and Z in the second picture are followed by or operations, so they are all True jumps.</p>
</li>
<li>
<p>If there is no logical operator behind, that is, the entire judgment statement ends, False jumps and True continues to execute. This rule is the same as for <code>and</code> above. This is true for the last judgment statement in the above four figures.</p>
</li>
</ul>
</li>
<li>
<p>Rules for jump target positions:</p>
<ul>
<li>
<p>If the same jump condition continues, jump to the same position. For example, there are 3 consecutive False jumps in the first picture, and 2 consecutive True jumps in the second picture; and the two False jumps in the third picture are not continuous, so the jump positions are different. Then during syntax analysis, if the two operands have the same jump condition, the jump list is merged.</p>
</li>
<li>
<p>If different jump conditions are encountered, terminate the previous jump list and jump to the end of the current judgment statement. For example, the False of Z in the second figure terminates the previous two True jump lists and jumps to the end of the Z statement; another example is the False jump list before the termination of B’s True in the third figure, and jumps to After the B statement.</p>
</li>
<li>
<p>However, the fourth picture does not seem to comply with the above two rules. The two False jumps are not continuous but connected, or the True jump of X does not end the False jump list of A. This is because A does not operate with <code>X</code>, but with <code>(X or Y)</code>; you need to ask <code>(X or Y)</code> first, and the True jump of X is brand new at this time, and you don’t know the previous The False jump list of A; and then when asking <code>A and (X or Y)</code>, the two jump lists of True and False coexist; the False at the end of the final statement merges the False jump list of A before, and Termination of X's True jump list.</p>
</li>
<li>
<p>The end of the judgment statement corresponds to the False jump, so the True jump list will be terminated and the False jump list will continue. After the end of the block, terminate the False jumpGo to the end of the block list. This is the case in the 4 figures above.</p>
</li>
</ul>
</li>
</ul>
<p>So far, the preparation knowledge has been introduced. Let's start coding.</p>
<h2 id="bytecode"><a class="header" href="#bytecode">Bytecode</a></h2>
<p>Several conditional judgment statements in the control structure in the previous chapter, including <code>if</code>, <code>while</code>, and <code>repeat..until</code>, etc., all deal with the judgment conditions and jump on False, so there is only one bytecode for testing and jumping, namely <code>Test</code>. But now we need 2 kinds of jumps, jump on False and jump on True. For this reason, we remove the previous <code>Test</code> and add 2 bytecodes:</p>
<pre><code class="language-rust  ignore">pub enum ByteCode {
     TestAndJump(u8, i16), // If Test is True, then Jump.
     TestOrJump(u8, i16), // Jump if Test is False. Same function as `Test` in the previous chapter.</code></pre>
<p>The &quot;And&quot; and &quot;Or&quot; in the naming have nothing to do with the logical operations introduced in this section, but are derived from the method names of the Option and Error types in the Rust language, meaning &quot;and then&quot; and &quot;otherwise then&quot; respectively. However, in the two examples at the beginning of this section, <code>t and t.k</code> can be described as: if t exists &quot;then then&quot; take t.k, <code>t.k or 100</code> can be described as: if t.k exists then take its value &quot;otherwise then&quot; Take 100. It can also be said to be related.</p>
<p>It’s just that the first jump rule introduced above, if it is followed by <code>and</code> operation, False jumps, corresponding to <code>TestOrJump</code>. The <code>and</code> and <code>Or</code> here do not correspond, but it doesn't matter much.</p>
<p>In the official Lua implementation, there is still only one bytecode <code>TEST</code>, which is associated with two parameters: the stack address of the judgment condition (same as ours), and the jump condition (True jump or False jump). For the specific jump position, you need to add a <code>JUMP</code> bytecode for an unconditional jump. It seems that 2 bytecodes are not very efficient. This is done for another application scenario, which will be introduced in the next section.</p>
<h2 id="expdesc"><a class="header" href="#expdesc">ExpDesc</a></h2>
<p>When parsing logical operators to generate jump bytecodes, the destination of the jump is not yet known. Only one bytecode placeholder can be generated first, and the parameter of the jump position is left blank. The parameters are filled in after the destination location is determined later. This approach is the same as when we introduced control structures in the previous chapter. The difference is that there was only one jump bytecode in the previous chapter, but this time there may be multiple bytecode zippers, such as the first picture above, 3 bytecode jumps Go to the same location. This zipper may be a True jump or a False jump, or these two chains may exist at the same time, such as when Y is resolved in the fourth figure above. So a new ExpDesc type is needed to save the jump list. To this end, a new <code>Test</code> type is defined as follows:</p>
<pre><code class="language-rust  ignore">enum ExpDesc {
     Test(usize, Vec&lt;usize&gt;, Vec&lt;usize&gt;), // (condition, true-list, false-list)</code></pre>
<p>Associate 3 parameters. The first one is to determine the position of the condition on the stack. No matter what type (constant, variable, table index, etc.) it will be discharged to the stack first, and then the true or false will be judged. The next two parameters are the two jump lists of True and False, and the contents are the positions of the bytecodes that need to be completed.</p>
<p>In the official implementation of Lua, the jump list is implemented by jumping to the blank parameters in the bytecode. For example, if there are three consecutive False jumps in the first figure above, the bytecodes generated by judging A, B, and C are <code>JUMP 0</code>, <code>JUMP $A</code>, <code>JUMP $B</code>, and then save them in ExpDesc <code>$C</code>. In this way, <code>$B</code> can be found through <code>$C</code>, <code>$A</code> can be found through <code>$B</code>, and the parameter <code>0</code> indicates the end of the linked list. Finally, while traversing, it is uniformly fixed as <code>JUMP $end</code>. This design is very efficient, without additional storage, and the zipper can be realized by using the Jump parameter that is temporarily left blank. At the same time, it is also slightly obscure and error-prone. This kind of full use of resources and micro-manipulation of memory according to bits is a very typical practice of C language projects. The Rust language standard library provides a list Vec, although it will generate memory allocation on the heap, which slightly affects performance, but the logic is much clearer and clear at a glance. As long as it is not a performance bottleneck, obscure and dangerous practices should be avoided as much as possible, especially when using the safety-oriented Rust language.</p>
<h2 id="syntax-analysis"><a class="header" href="#syntax-analysis">Syntax Analysis</a></h2>
<p>Now it is finally ready to parse. Start with the binary operation part of the <code>exp()</code> function. Before introducing the <a href="./ch05-02.binary_ops.html#evaluation-order">evaluation order</a> of binary numerical operations, the first operand must be processed first. It is also introduced at the beginning of this section that for the processing order of logical operations, due to the short-circuit characteristics, the first operation and possible jumps must be processed first, and then the second operand can be parsed. So, before continuing to parse the second operand, the jump is handled:</p>
<pre><code class="language-rust  ignore">     fn preprocess_binop_left(&amp;mut self, left: ExpDesc, binop: &amp;Token) -&gt; ExpDesc {
         match binop {
             Token::And =&gt; ExpDesc::Test(0, Vec::new(), self. test_or_jump(left)),
             Token::Or =&gt; ExpDesc::Test(0, self. test_and_jump(left), Vec::new()),

             _ =&gt; // Omit the part of other types of discharge
         }
     }</code></pre>
<p>In this function, the processing part of logical operation is added. Take <code>and</code> as an example, generate <code>ExpDesc::Test</code> type, temporarily save the processed 2 jump lists, and the associated first parameter is useless, fill in 0 here. Call the <code>test_or_jump()</code> function to process the jump list. According to the rules introduced above, the and operator corresponds to the False jump, which will terminate the previous True jump list, so the <code>test_or_jump()</code> function will terminate the previous True jump list and return only the False jump list. Then create a new list <code>Vec::new()</code> here as the True jump list.</p>
<p>Look at the specific implementation of <code>test_or_jump()</code>:</p>
<pre><code class="language-rust  ignore">     fn test_or_jump(&amp;mut self, condition: ExpDesc) -&gt; Vec&lt;usize&gt; {
         let (icondition, true_list, mut false_list) = match condition {
             // It is a constant of True, no need to test or jump, skip it directly.
             // Example: while true do ... end
             ExpDesc::Boolean(true) | ExpDesc::Integer(_) | ExpDesc::Float(_) | ExpDesc::String(_) =&gt; {
                 return Vec::new();
             }

             // The first operand is already of type Test, indicating that this
             // is not the first logical operator.
             // Just return the existing two jump lists directly.
             ExpDesc::Test(icondition, true_list, false_list) =&gt;
                 (icondition, Some(true_list), false_list),

             // The first operand is another type, indicating that this is the
             // first logical operator.
             // Only need to discharge the first operand to the stack.
             // There was no True jump list before, so return None.
             // There was no False jump list before, so create a new list to save
             // this jump instruction.
             _ =&gt; (self. discharge_any(condition), None, Vec::new()),
         };

         // generate TestOrJump, but leave the second parameter blank
         self.byte_codes.push(ByteCode::TestOrJump(icondition as u8, 0));

         // Put the newly generated bytecode, if it is in the False jump list,
         // for subsequent repair
         false_list.push(self.byte_codes.len() - 1);

         // Finalize the previous True jump list and jump here, if any
         if let Some(true_list) = true_list {
             self.fix_test_list(true_list);
         }

         // return False jump list
         false_list
     }</code></pre>
<p>For the <code>or</code> operator and the corresponding <code>test_and_jump()</code> function, it is similar, just flip the True and False jump lists. It will not be introduced here.</p>
<p>After processing the first operand and the jump, it is very simple to process the second operand, just connect the jump list:</p>
<pre><code class="language-rust  ignore">     fn process_binop(&amp;mut self, binop: Token, left: ExpDesc, right: ExpDesc) -&gt; ExpDesc {
         match binop {
             // omit other binary operator processing
             Token::And | Token::Or =&gt; {
                 // The first operand has been converted to ExpDesc::Test in preprocess_binop_left() above
                 if let ExpDesc::Test(_, mut left_true_list, mut left_false_list) = left {
                     let icondition = match right {
                         // If the second operand is also of Test type, such as the example
                         // of `A and (X or Y)` in the fourth figure above in this section,
                         // Then connect the two jump lists separately.
                         ExpDesc::Test(icondition, mut right_true_list, mut right_false_list) =&gt; {
                             left_true_list.append(&amp;mut right_true_list);
                             left_false_list.append(&amp;mut right_false_list);
                             icondition
                         }
                         // If the second operand is another type, there is no need to deal with the jump list
                         _ =&gt; self.discharge_any(right),
                     };

                     // After returning to the connection, I want to create a new jump list
                     ExpDesc::Test(icondition, left_true_list, left_false_list)
                 } else {
                     panic!(&quot;impossible&quot;);
                 }
             }</code></pre>
<p>After dealing with the binary operation part, the next step is the application scenario. This section only introduces the application scenarios used as judgment conditions, and the evaluation will be introduced in the next section. Several control structure statements (if, while, repeat..until, etc.) directly process the jump bytecode, and the code logic is similar. In the jump rules introduced at the beginning of this section, the judgment statement of the entire logical operation ends, which is a False jump, so calling the test_or_jump() function just introduced can replace and simplify the code that directly processes bytecodes in the previous chapter logic. Here we still use the if statement as an example:</p>
<pre><code class="language-rust  ignore">     fn do_if_block(&amp;mut self, jmp_ends: &amp;mut Vec&lt;usize&gt;) -&gt; Token {
         let condition = self. exp();

         // In the previous chapter, here is to generate Test bytecode.
         // Now, replace and simplify to the test_or_jump() function.
         // Terminate the True jump list and return a new False jump list.
         let false_list = self. test_or_jump(condition);

         self.lex.expect(Token::Then);

         let end_token = self. block();

         if matches!(end_token, Token::Elseif | Token::Else) {
             self.byte_codes.push(ByteCode::Jump(0));
             jmp_ends.push(self.byte_codes.len() - 1);
         }

         // In the last chapter, here is to fix a Test bytecode just generated.
         // Now, a False jump list needs to be modified.
         self.fix_test_list(false_list);

         end_token
     }</code></pre>
<p>This completes the syntax analysis part.</p>
<h2 id="virtual-machine-execution"><a class="header" href="#virtual-machine-execution">Virtual Machine Execution</a></h2>
<p>The execution part of the virtual machine first needs to process the newly added 2 bytecodes, which are very simple and will be ignored here. What needs to be said is the details of a stack operation. The function when assigning a value to the stack before is as follows:</p>
<pre><code class="language-rust  ignore">     fn set_stack(&amp;mut self, dst: u8, v: Value) {
         let dst = dst as usize;
         match dst.cmp(&amp;self.stack.len()) {
             Ordering::Equal =&gt; self. stack. push(v),
             Ordering::Less =&gt; self.stack[dst] = v,
             Ordering::Greater =&gt; panic!(&quot;fail in set_stack&quot;),
         }
     }</code></pre>
<p>First determine whether the target address dst is within the range of the stack:</p>
<ul>
<li>If it is, assign it directly;</li>
<li>If it is not and it is just the next position, use <code>push()</code> to push it onto the stack;</li>
<li>If not, and past the next position, it was impossible to appear before, so call <code>panic!()</code>.</li>
</ul>
<p>However, the short-circuit characteristics of logic operations may lead to the above-mentioned third situation. For example the following statement:</p>
<pre><code class="language-lua">if (g1 or g2) and g3 then
end
</code></pre>
<p>According to our analysis method, the following temporary variables will be generated, occupying the position on the stack:</p>
<pre><code>|      |
+------+
|  g1  |
+------+
|  g2  |
+------+
|  g3  |
+------+
|      |
</code></pre>
<p>But during execution, if <code>g1</code> is true, the processing of <code>g2</code> will be skipped, and <code>g3</code> will be processed directly. At this time, the position of g2 in the above figure is not set, then g3 will exceed the top of the stack position, as shown in the figure below:</p>
<pre><code>|      |
+------+
|  g1  |
+------+
|      |
:      :
:      : &lt;-- set g3, beyond the top of the stack
</code></pre>
<p>Therefore, it is necessary to modify the above <code>set_stack()</code> function to support setting elements beyond the top of the stack. This can be achieved by calling <code>set_vec()</code>.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>So far, the application scenario of logical operation in conditional judgment has been completed. This can be tested with the examples in the figures at the beginning of this section. omitted here.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-00.logical_relational.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch07-02.logical_in_evalue.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-00.logical_relational.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07-02.logical_in_evalue.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
