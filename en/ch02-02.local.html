<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Local Variables - Build a Lua Interpreter in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> Basic Compilation Principles</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> Value and Type</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html"><strong aria-hidden="true">1.4.</strong> Let's Do It!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> Variables and Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> More Types</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html" class="active"><strong aria-hidden="true">2.2.</strong> Local Variables</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> Variable Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> String Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> String Definition</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> Type Conversion</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> Input Type</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode and UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> Garbage Collection and Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> Table and ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> Table Definition</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> Table Construction</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc Concept</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc Rewrite</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> Table Read/Write and BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> Numerical Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> Unary Operations</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> Binary Operations</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> Integer and Float</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> Control Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if Statement</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif and else Branches</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while and break Statements</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat and continue Statements</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> numerical-for Statement</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto Statement</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> Logical and Relational Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> Logical Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> Logical Operations in Evalue</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> Relational Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> Relational Operations in Evalue</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> Definition and Call</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> Return Value</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust Functions and API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> Tail Call</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> Closure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue Escape and Closure</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> Escape from Block and goto</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust Closures</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> generic-for Statement</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> Environment _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">To Be Continued</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build a Lua Interpreter in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="local-variables"><a class="header" href="#local-variables">Local Variables</a></h1>
<p>This section describes the definition and access of local variables, while the assignment is covered in the next section.</p>
<p>For the sake of simplicity, we only support the simplified format for defining local variable statements: <code>local name = expression</code>, that is to say, it does not support multiple variables or no initialization. We will support the full format in later chapter. The target code is as follows:</p>
<pre><code class="language-lua">local a = &quot;hello, local!&quot; -- define new local var 'a'
print(a) -- use 'a'
</code></pre>
<p>How are local variables managed, stored, and accessed? First refer to the results of <code>luac</code>:</p>
<pre><code>main &lt;local.lua:0,0&gt; (6 instructions at 0x6000006e8080)
0+ params, 3 slots, 1 upvalue, 1 local, 2 constants, 0 functions
	1	[1]	VARARGPREP	0
	2	[1]	LOADK    	0 0	; &quot;hello, world!&quot;
	3	[2]	GETTABUP 	1 0 1	; _ENV &quot;print&quot;
	4	[2]	MOVE     	2 0
	5	[2]	CALL     	1 2 1	; 1 in 0 out
	6	[2]	RETURN   	1 1 1	; 0 out
</code></pre>
<p>Compared with the program that directly prints &quot;hello, world!&quot; in the previous chapter, there are several differences:</p>
<ul>
<li><code>1 local</code> in the second line of the output, indicating that there is 1 local variable. But this is just an illustration and has nothing to do with the following bytecode.</li>
<li>LOADK, loads the constant at index 0 of the stack. Corresponding to line [1] of the source code, that is, defining local variables. It can be seen that variables are stored on the stack and assigned during execution.</li>
<li>The target address of GETTABUP is 1 (it was 0 in the previous chapter), that is, <code>print</code> is loaded into location 1, because location 0 is used to store local variables.</li>
<li>MOVE, the new bytecode, is used to copy the value in the stack. The two parameters are the destination index and the source index. Here is to copy the value of index 0 to index 2. It is to use the local variable a as the parameter of print.</li>
</ul>
<p>After the first 4 bytecodes are executed, the layout on the stack is as follows:</p>
<pre><code>  +-----------------+   MOVE
0 | local a         |----\
  +-----------------+    |
1 | print           |    |
  +-----------------+    |
2 | &quot;hello, world!&quot; |&lt;---/
  +-----------------+
  |                 |
</code></pre>
<p>It can be seen that local variables are stored on the stack during execution. In the previous chapter, the stack was only used for <em>function calls</em>, and now it <em>stores local variables</em> too. Relatively speaking, local variables are more persistent and only become invalid after the end of the current block. The function call is invalid after the function returns.</p>
<h2 id="define-local-variables"><a class="header" href="#define-local-variables">Define Local Variables</a></h2>
<p>Now we add support of handling local variables. First define the local variable table <code>locals</code>. In the <a href="./ch01-03.value_and_type.html">value and type</a> section, it shows that Lua variables only contain variable name information, but no type information, so this table only saves variable names, defined as<code> Vec&lt;String&gt;</code>. In addition, this table is only used during syntax analysis, but not needed during virtual machine execution, so it does not need to be added to <code>ParseProto</code>.</p>
<p>Currently, 2 statements are supported (2 formats of function calls):</p>
<pre><code>Name String
Name ( exp )
</code></pre>
<p>Among them, <code>exp</code> is an expression, which currently supports a variety of constants, such as strings and numbers.</p>
<p>Now we add a new statement, the simplified form of defining a local variable:</p>
<pre><code>localName = exp
</code></pre>
<p>This also includes <code>exp</code>. So extract this part as a function <code>load_exp()</code>. Then the syntax analysis code corresponding to the definition of local variables is as follows:</p>
<pre><code class="language-rust  ignore">     Token::Local =&gt; { // local name = exp
         let var = if let Token::Name(var) = lex.next() {
             var // can not add to locals now
         } else {
             panic!(&quot;expected variable&quot;);
         };

         if lex.next() != Token::Assign {
             panic!(&quot;expected `=`&quot;);
         }

         load_exp(&amp;mut byte_codes, &amp;mut constants, lex.next(), locals.len());

         // add to locals after load_exp()
         locals. push(var);
     }</code></pre>
<p>The code is relatively simple and needs no explaination. The <code>load_exp()</code> function refers to the following section.</p>
<p>What needs special attention is that when the variable name <code>var</code> is first parsed, it cannot be directly added to the local variable table <code>locals</code>, but can only be added <em>after</em> the expression is parsed. It can be considered that when <code>var</code> is parsed, there is no complete definition of local variables; it needs to wait until the end of the entire statement to complete the definition and add it to the local variable table. The following subsections explain the specific reasons.</p>
<h2 id="access-local-variables"><a class="header" href="#access-local-variables">Access Local Variables</a></h2>
<p>Now access the local variable, that is, the code <code>print(a)</code>. That is to increase the processing of local variables in <code>exp</code>.</p>
<blockquote>
<p>In fact, in the <code>Name ( exp )</code> format of the function call statement in the previous section, you can add global variables in <code>exp</code>. In this way, Lua code such as <code>print(print)</code> can be supported. It's just that at that time, I only cared about adding other types of constants, and forgot to support global variables. This also reflects the current state, that is, the addition of functional features is all based on feeling, while the completeness or even correctness cannot be guaranteed at all. We will address this issue in subsequent chapters.</p>
</blockquote>
<p>So modify the code of <code>load_exp()</code> (the processing part of the original various constant types is omitted here):</p>
<pre><code class="language-rust  ignore">fn load_exp(byte_codes: &amp;mut Vec&lt;ByteCode&gt;, constants: &amp;mut Vec&lt;Value&gt;,
         locals: &amp;Vec&lt;String&gt;, token: Token, dst: usize) {

     let code = match token {
         ... // other type consts, such as Token::Float()...
         Token::Name(var) =&gt; load_var(constants, locals, dst, var),
         _ =&gt; panic!(&quot;invalid argument&quot;),
     };
     byte_codes. push(code);
}

fn load_var(constants: &amp;mut Vec&lt;Value&gt;, locals: &amp;Vec&lt;String&gt;, dst: usize, name: String) -&gt; ByteCode {
     if let Some(i) = locals.iter().rposition(|v| v == &amp;name) {
         // local variable
         ByteCode::Move(dst as u8, i as u8)
     } else {
         // global variable
         let ic = add_const(constants, Value::String(name));
         ByteCode::GetGlobal(dst as u8, ic as u8)
     }
}</code></pre>
<p>The processing of variables in the <code>load_exp()</code> function is also placed in a separate <code>load_var()</code> function, because the &quot;function&quot; part of the previous function call statement can also call this <code>load_var()</code> function, so that local variables can also be supported as a function.</p>
<p>The processing logic for variables is to search the Name in the local variable table <code>locals</code>,</p>
<ul>
<li>if exist, it is a local variable, then generate the <code>Move</code> bytecode, which is a new bytecode;</li>
<li>otherwise, it is a global variable. The handling process was introduced in the previous chapter, so it is skipped here.</li>
</ul>
<blockquote>
<p>It is foreseeable that after supporting Upvalue, it will also be handled in this function.</p>
</blockquote>
<p>When the <code>load_var()</code> function looks up variables in the variable table, it searches from the back to the front, that is, the <code>.rposition()</code> function is used. This is because we did not check for duplicate names when registering local variables. If there is a duplicate name, it will be registered as usual, that is, it will be pushed at the end of the local variable table. In this case, the reverse search will find the variable registered later, and the variable registered first will never be located. It is equivalent to the variable registered later covering the previous variable. For example, the following code is legal and outputs <code>456</code>:</p>
<pre><code class="language-lua">local a = 123
local a = 456
print(a) -- 456
</code></pre>
<p>I find this approach very ingenious. If you check if a local variable exists every time adding a local variable, it will definitely consume performance. And this kind of repeated definition of local variables is rare (maybe I am ignorant), and it is not worth checking duplication (whether it is error reporting or reuse) for this small probability situation. The current approach (reverse lookup) not only guarantees performance, but also can correctly support this situation of repeated definitions.</p>
<p>There are similar shadow variables in Rust. However, I guess Rust should not be able to ignore it so simply, because when a variable in Rust is invisible (such as being shadowed), it needs to be dropped, so it is still necessary to specially judge this shadow situation and handle it specially.</p>
<p>Another problem is that as mentioned at the end of the previous paragraph <a href="#define-local-variables">Define Local Variables</a>, when the variable name <code>var</code> is parsed, it cannot be directly added to the local variable table <code>locals</code>, but must only be added after parsing the expression. At that time, because there was no &quot;access&quot; to the local variable, the specific reason was not explained. Now it can be explained. For example for the following code:</p>
<pre><code class="language-lua">local print = print
</code></pre>
<p>This kind of statement is relatively common in Lua code, that is, assign a commonly used &quot;global variable&quot; to a &quot;local variable&quot; with the same name, so that it will be the local variable accessed when this name is referenced later. Local variables are much faster than global variables (local variables are accessed through the stack index, while global variables need to look up the global variable table in real time, which is the difference between the two bytecodes of <code>Move</code> and <code>GetGlobal</code>), which will improve performance.</p>
<p>Going back to the question just now, if the variable name <code>print</code> is just added to the local variable table when it is parsed, then when the expression <code>print</code> behind <code>=</code> is parsed, the local variable table will find the newly added <code>print</code>, then it is equivalent to assigning the local variable <code>print</code> to the local variable <code>print</code>, and the cycle is meaningless (if you do this, <code>print</code> will be assigned the value of nil).</p>
<p>To sum up, variables must be added to the local variable table after parsing the expression behind <code>=</code>.</p>
<h2 id="where-the-function-is-called"><a class="header" href="#where-the-function-is-called">Where the Function is Called</a></h2>
<p>Previously, our interpreter only supported function call statements, so the stack is only a place for function calls. When a function call is executed, the function and parameters are fixed at 0 and 1 respectively. Now that local variables are supported, the stack is not just a place for function calls, and the positions of functions and parameters are not fixed, but need to become the first free position on the stack, that is, the next position of local variables. to this end:</p>
<ul>
<li>
<p>During syntax analysis, we can get the number of local variables through <code>locals.len()</code>, that is, the first free position on the stack.</p>
</li>
<li>
<p>When the virtual machine is executing, we need to add a field <code>func_index</code> in <code>ExeState</code>, set this field before the function call to indicate this position, and use it in the function. The corresponding codes are as follows:</p>
</li>
</ul>
<pre><code class="language-rust  ignore">     ByteCode::Call(func, _) =&gt; {
         self.func_index = func as usize; // set func_index
         let func = &amp;self. stack[self. func_index];
         if let Value::Function(f) = func {
             f(self);
         } else {
             panic!(&quot;invalid function: {func:?}&quot;);
         }
     }</code></pre>
<pre><code class="language-rust  ignore">fn lib_print(state: &amp;mut ExeState) -&gt; i32 {
     println!(&quot;{:?}&quot;, state.stack[state.func_index + 1]); // use func_index
     0
}</code></pre>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>So far, we have realized the definition and access of local variables, and also re-organized the code in the process, making the previous function call statement more powerful. Both the function and the parameter support global variables and local variables. So the 2-line object code at the beginning of this article is too simple. You can try the following code:</p>
<pre><code class="language-lua">local a = &quot;hello, local!&quot; -- define a local by string
local b = a -- define a local by another local
print(b) -- print local variable
print(print) -- print global variable
local print = print --define a local by global variable with same name
print &quot;I'm local-print!&quot; -- call local function
</code></pre>
<p>Results of the:</p>
<pre><code>[src/parse.rs:71] &amp;constants = [
     hello, local!,
     print,
     I'm local-print!,
]
byte_codes:
   LoadConst(0, 0)
   Move(1, 0)
   GetGlobal(2, 1)
   Move(3, 1)
   Call(2, 1)
   GetGlobal(2, 1)
   GetGlobal(3, 1)
   Call(2, 1)
   GetGlobal(2, 1)
   Move(3, 2)
   LoadConst(4, 2)
   Call(3, 1)
hello, local!
function
I'm local-print!
</code></pre>
<p>In line with expectations! The bytecodes are a bit long, you can compare it with the output of <code>luac</code>. We used to be able to analyze and imitate the bytecode sequence compiled by <code>luac</code>, but now we can compile and output bytecode independently. Great progress!</p>
<h2 id="oo-in-syntax-analysis-code"><a class="header" href="#oo-in-syntax-analysis-code">OO in Syntax Analysis Code</a></h2>
<p>The feature has been completed. However, with the increase of features, the code in the syntax analysis part becomes more chaotic. For example, the definition of the above <code>load_exp()</code> function has a bunch of parameters. In order to organize the code, the syntax analysis is also transformed into an object-oriented model, and methods are defined around <code>ParseProto</code>. These methods can get all the information through <code>self</code>, so there is no need to pass many parameters. For specific changes, see <a href="https://github.com/WuBingzheng/build-lua-in-rust/commit/f89d2fd6bca4574d1d18d60f9363731bfd89e4b1">commit f89d2fd</a>.</p>
<p>Bringing together several independent members also presents a small problem, a problem specific to the Rust language. For example, the original code for reading a string constant is as follows, first call <code>load_const()</code> to generate and return the bytecode, and then call <code>byte_codes.push()</code> to save the bytecode. These two function calls can be written together:</p>
<pre><code class="language-rust  ignore">byte_codes.push(load_const(&amp;mut constants, iarg, Value::String(s)));</code></pre>
<p>After changing to object-oriented mode, the code is as follows:</p>
<pre><code class="language-rust  ignore">self.byte_codes.push(self.load_const(iarg, Value::String(s)));</code></pre>
<p>But this cannot be compiled, and the error is as follows:</p>
<pre><code>error[E0499]: cannot borrow `*self` as mutable more than once at a time
  --&gt; src/parse.rs:70:38
   |
70 |                 self.byte_codes.push(self.load_const(iarg, Value::String(s)));
   |                 ---------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-
   |                 |               |    |
   |                 |               |    second mutable borrow occurs here
   |                 |               first borrow later used by call
   |                 first mutable borrow occurs here
   |
help: try adding a local storing this argument...
  --&gt; src/parse.rs:70:38
   |
70 |                 self.byte_codes.push(self.load_const(iarg, Value::String(s)));
   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: ...and then using that local as the argument to this call
  --&gt; src/parse.rs:70:17
   |
70 |                 self.byte_codes.push(self.load_const(iarg, Value::String(s)));
   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0499`.
</code></pre>
<p>Although the Rust compiler is very strict, the error message is still very clear, and even gives correct modification method.</p>
<p><code>self</code> is referenced 2 times by mut. Although <code>self.byte_codes</code> is not used in <code>self.load_const()</code>, and there is no conflict in fact, the compiler does not know these details. The compiler only knows that <code>self</code> is referenced twice. This is the consequence of bringing together multiple members. The solution is to introduce a local variable as suggested by Rust, and then split this line of code into two lines:</p>
<pre><code class="language-rust  ignore">let code = self.load_const(iarg, Value::String(s));
self.byte_codes.push(code);</code></pre>
<p>The situation here is simple and easy to fixed, because the returned bytecode <code>code</code> is not related to <code>self.constants</code>, so it has no connection with <code>self</code>, so <code>self.byte_codes</code> can be used normally below. If the content returned by a method is still associated with this data structure, the solution becomes not so simple. This situation will be encountered later when the virtual machine is executed.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02-01.more_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch02-03.assignment.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02-01.more_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch02-03.assignment.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
