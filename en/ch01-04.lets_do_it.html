<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Let&#x27;s Do It! - Build a Lua Interpreter in Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="PREFACE.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00.hello_world.html"><strong aria-hidden="true">1.</strong> hello, world!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01.principles.html"><strong aria-hidden="true">1.1.</strong> Basic Compilation Principles</a></li><li class="chapter-item expanded "><a href="ch01-02.byte_codes.html"><strong aria-hidden="true">1.2.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="ch01-03.value_and_type.html"><strong aria-hidden="true">1.3.</strong> Value and Type</a></li><li class="chapter-item expanded "><a href="ch01-04.lets_do_it.html" class="active"><strong aria-hidden="true">1.4.</strong> Let's Do It!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00.variables.html"><strong aria-hidden="true">2.</strong> Variables and Assignments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01.more_types.html"><strong aria-hidden="true">2.1.</strong> More Types</a></li><li class="chapter-item expanded "><a href="ch02-02.local.html"><strong aria-hidden="true">2.2.</strong> Local Variables</a></li><li class="chapter-item expanded "><a href="ch02-03.assignment.html"><strong aria-hidden="true">2.3.</strong> Variable Assignment</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00.optimize_string.html"><strong aria-hidden="true">3.</strong> String Optimization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01.string_type.html"><strong aria-hidden="true">3.1.</strong> String Definition</a></li><li class="chapter-item expanded "><a href="ch03-02.from_trait.html"><strong aria-hidden="true">3.2.</strong> Type Conversion</a></li><li class="chapter-item expanded "><a href="ch03-03.read_input.html"><strong aria-hidden="true">3.3.</strong> Input Type</a></li><li class="chapter-item expanded "><a href="ch03-04.unicode_utf8.html"><strong aria-hidden="true">3.4.</strong> Unicode and UTF-8</a></li><li class="chapter-item expanded "><a href="ch03-05.gc_vs_rc.html"><strong aria-hidden="true">3.5.</strong> Garbage Collection and Rc</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00.table.html"><strong aria-hidden="true">4.</strong> Table and ExpDesc</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01.table_definition.html"><strong aria-hidden="true">4.1.</strong> Table Definition</a></li><li class="chapter-item expanded "><a href="ch04-02.table_constructor.html"><strong aria-hidden="true">4.2.</strong> Table Construction</a></li><li class="chapter-item expanded "><a href="ch04-03.expdesc.html"><strong aria-hidden="true">4.3.</strong> ExpDesc Concept</a></li><li class="chapter-item expanded "><a href="ch04-04.expdesc_rewrite.html"><strong aria-hidden="true">4.4.</strong> ExpDesc Rewrite</a></li><li class="chapter-item expanded "><a href="ch04-05.table_rw_and_bnf.html"><strong aria-hidden="true">4.5.</strong> Table Read/Write and BNF</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00.arithmetic_ops.html"><strong aria-hidden="true">5.</strong> Numerical Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01.unary_ops.html"><strong aria-hidden="true">5.1.</strong> Unary Operations</a></li><li class="chapter-item expanded "><a href="ch05-02.binary_ops.html"><strong aria-hidden="true">5.2.</strong> Binary Operations</a></li><li class="chapter-item expanded "><a href="ch05-03.int_and_float.html"><strong aria-hidden="true">5.3.</strong> Integer and Float</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00.control_structures.html"><strong aria-hidden="true">6.</strong> Control Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01.if.html"><strong aria-hidden="true">6.1.</strong> if Statement</a></li><li class="chapter-item expanded "><a href="ch06-02.elseif_else.html"><strong aria-hidden="true">6.2.</strong> elseif and else Branches</a></li><li class="chapter-item expanded "><a href="ch06-03.while_break.html"><strong aria-hidden="true">6.3.</strong> while and break Statements</a></li><li class="chapter-item expanded "><a href="ch06-04.repeat_continue.html"><strong aria-hidden="true">6.4.</strong> repeat and continue Statements</a></li><li class="chapter-item expanded "><a href="ch06-05.numerical-for.html"><strong aria-hidden="true">6.5.</strong> numerical-for Statement</a></li><li class="chapter-item expanded "><a href="ch06-06.goto.html"><strong aria-hidden="true">6.6.</strong> goto Statement</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00.logical_relational.html"><strong aria-hidden="true">7.</strong> Logical and Relational Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01.logical_in_condition.html"><strong aria-hidden="true">7.1.</strong> Logical Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-02.logical_in_evalue.html"><strong aria-hidden="true">7.2.</strong> Logical Operations in Evalue</a></li><li class="chapter-item expanded "><a href="ch07-03.relational_in_condition.html"><strong aria-hidden="true">7.3.</strong> Relational Operations in Conditional Judgment</a></li><li class="chapter-item expanded "><a href="ch07-04.relational_in_evalue.html"><strong aria-hidden="true">7.4.</strong> Relational Operations in Evalue</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00.function.html"><strong aria-hidden="true">8.</strong> Function</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01.define_and_call.html"><strong aria-hidden="true">8.1.</strong> Definition and Call</a></li><li class="chapter-item expanded "><a href="ch08-02.arguments.html"><strong aria-hidden="true">8.2.</strong> Arguments</a></li><li class="chapter-item expanded "><a href="ch08-03.results.html"><strong aria-hidden="true">8.3.</strong> Return Value</a></li><li class="chapter-item expanded "><a href="ch08-04.rust_functions_and_api.html"><strong aria-hidden="true">8.4.</strong> Rust Functions and API</a></li><li class="chapter-item expanded "><a href="ch08-05.tail_call.html"><strong aria-hidden="true">8.5.</strong> Tail Call</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00.closure.html"><strong aria-hidden="true">9.</strong> Closure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01.upvalue.html"><strong aria-hidden="true">9.1.</strong> Upvalue</a></li><li class="chapter-item expanded "><a href="ch09-02.escape_and_closure.html"><strong aria-hidden="true">9.2.</strong> Upvalue Escape and Closure</a></li><li class="chapter-item expanded "><a href="ch09-03.escape_from_block_and_goto.html"><strong aria-hidden="true">9.3.</strong> Escape from Block and goto</a></li><li class="chapter-item expanded "><a href="ch09-04.rust_closure.html"><strong aria-hidden="true">9.4.</strong> Rust Closures</a></li><li class="chapter-item expanded "><a href="ch09-05.generic_for.html"><strong aria-hidden="true">9.5.</strong> generic-for Statement</a></li><li class="chapter-item expanded "><a href="ch09-06.environment.html"><strong aria-hidden="true">9.6.</strong> Environment _ENV</a></li></ol></li><li class="chapter-item expanded "><a href="TO_BE_CONTINUED.html">To Be Continued</a></li><li class="chapter-item expanded affix "><a href="REFERENCES.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Build a Lua Interpreter in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WuBingzheng/build-lua-in-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lets-do-it"><a class="header" href="#lets-do-it">Let's Do It</a></h1>
<p>The previous chapters introduced the basics of compilation principles, and defined the two most important concepts, ByteCode and Value. Next, we can start coding to implement our interpreter!</p>
<p>The code corresponding to this series of articles is all managed by Cargo that comes with Rust. Projects currently using the binary type will be changed to the library type in the future.</p>
<p>The minimalist interpreter to be implemented at present is very simple, with very little code. I wrote all the code in one file at the beginning. However, it is foreseeable that the code volume of this project will increase with the increase of features. So in order to avoid subsequent changes to the file, we directly create multiple files now:</p>
<ul>
<li>Program entry: <code>main.rs</code>;</li>
<li>Three components: lexical analysis <code>lex.rs</code>, syntax analysis <code>parse.rs</code>, and virtual machine <code>vm.rs</code>;</li>
<li>Two concepts: byte code <code>byte_code.rs</code>, and value <code>value.rs</code>.</li>
</ul>
<p>The latter two concepts and their codes have been introduced before. The other 4 files are described below. Let's start with the program entry.</p>
<h2 id="program-entry"><a class="header" href="#program-entry">Program Entry</a></h2>
<p>For the sake of simplicity, our interpreter has only one way of working, which is to accept a parameter as a Lua source code file, and then parse and execute it. Here is the code:</p>
<pre><code class="language-rust  ignore">use std::env;
use std::fs::File;

mod value;
mod bytecode;
mod lex;
mod parse;
mod vm;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    if args.len() != 2 {
        println!(&quot;Usage: {} script&quot;, args[0]);
        return;
    }
    let file = File::open(&amp;args[1]).unwrap();

    let proto = parse::load(file);
    vm::ExeState::new().execute(&amp;proto);
}</code></pre>
<p>The first 2 lines reference two standard libraries. <code>env</code> is used to <a href="https://doc.rust-lang.org/stable/book/ch12-01-accepting-command-line-arguments.html#reading-the-argument-values">obtain command line arguments</a>. <code>fs::File</code> is used to open Lua source files.</p>
<p>The middle lines refer to other <a href="https://doc.rust-lang.org/stable/book/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html">file modules</a> through <code>use</code> keyword.</p>
<p>Then look at the <code>main()</code> function. The first few lines read the parameters and open the source file. For the sake of simplicity, we use <code>unwrap()</code> 
to terminate the program if fail to open file. We will improve the error handing later.</p>
<p>The last 2 lines are the core function:</p>
<ul>
<li>First, the syntax analysis module <code>parse</code> (who also calls lexical analysis <code>lex</code> internally) parses the file and returns the parsing result <code>proto</code>;</li>
<li>Then create a virtual machine and execute <code>proto</code>.</li>
</ul>
<p>This process is different from Lua's officially APIs (<a href="https://www.lua.org/pil/24.1.html">complete example</a>) :</p>
<pre><code class="language-c">lua_State *L = lua_open(); // Create lua_State
luaL_loadfile(L, filename); // Parse and put the parsing result on the top of the stack
lua_pcall(L, 0, 0, 0); // top of execution stack
</code></pre>
<p>This is because the official implementation of Lua is a &quot;library&quot;, and the API only exposes the <code>lua_State</code> data structure, which contains both parsing and executing parts. So you must first create <code>lua_State</code>, and then call parsing and execution based on it. The parsing result is also passed through the stack of <code>Lua_state</code>. However, we currently do not have a similar unified state data structure, so we can only call the parsing and execution functions separately.</p>
<p>Let's look at the analysis and execution process respectively.</p>
<h2 id="lexical-analysis"><a class="header" href="#lexical-analysis">Lexical Analysis</a></h2>
<p>Although the <code>main()</code> function calls the syntax analysis <code>parse</code> module firstly, but the syntax analysis calls the lexical analysis <code>lex</code> module internally. So let's see the lexical analysis first.</p>
<p>The output of lexical analysis is Token stream. For the &quot;hello, world!&quot; program, you only need to use the two Tokens &quot;identity <code>print</code>&quot; and &quot;string <code>&quot;hello, world!&quot;</code>&quot;. For simplicity, we only support these two kinds of tokens for the time being. In addition, we also define an <code>Eos</code> to indicate the end of the file:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub enum Token {
    Name(String),
    String(String),
    Eos,
}</code></pre>
<p>Instead of returning a whole Token list after parsing the input file at one time, we provide a function similar to an iterator so that the syntax analysis module can be called on demand. To do this first define a lexical analyzer:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub struct Lex {
    input: File,
}</code></pre>
<p>For now only one member is included, the input file.</p>
<p>It provides 2 APIs: <code>new()</code> creates a parser based on the input file; <code>next()</code> returns the next Token.</p>
<pre><code class="language-rust  ignore">impl Lex {
     pub fn new(input: File) -&gt; Self ;
     pub fn next(&amp;mut self) -&gt; Token;
}</code></pre>
<p>The specific parsing process is pure and boring string handling, and the code is skipped.</p>
<p>According to the Rust convention, the return value of the <code>next()</code> function here should be defined as <code>Option&lt;Token&gt;</code>, where <code>Some&lt;Token&gt;</code> means that a new token has been read, and <code>None</code> means the end of the file. But since <code>Token</code> itself is an <code>enum</code>, it seems more convenient to directly add an <code>Eos</code> in it. And if it is changed to the <code>Option&lt;Token&gt;</code> type, then an additional layer of judgment will be required in the syntax analysis call, as shown in the following code. So I chose to add the <code>Eos</code> type.</p>
<pre><code class="language-rust  ignore">loop {
     if let Some(token) = lex.next() { // extra check
         match token {
             ... // parse
         }
     } else {
         break
     }
}</code></pre>
<h2 id="syntax-analysis"><a class="header" href="#syntax-analysis">Syntax Analysis</a></h2>
<p>The parsing result <code>proto</code> in the <code>main()</code> function concats the parsing and execution phases. But in view of Rust's powerful type mechanism, <code>proto</code> does not show a specific type in the above code. Now let's define it. It has been introduced in the <a href="./ch01-02.byte_codes.html">bytecode</a> section that the analysis result needs to contain two parts: bytecode sequence and constant table. Then you can define the format of the parsing result as follows:</p>
<pre><code class="language-rust  ignore">#[derive(Debug)]
pub struct ParseProto {
    pub constants: Vec::&lt;Value&gt;,
    pub byte_codes: Vec::&lt;ByteCode&gt;,
}</code></pre>
<p>The constant table <code>constants</code> is a <code>Vec</code> containing the <code>Value</code> type, and the bytecode sequence <code>byte_codes</code> is a <code>Vec</code> containing the <code>ByteCode</code> type. They are both <code>Vec</code> structures with the same functionality but different containment types. In the ancient C language, to include the two types <code>Value</code> and <code>ByteCode</code>, either write a set of codes for each type, or use complex features such as macros or function pointers. <a href="https://doc.rust-lang.org/stable/book/ch10-01-syntax.html">Generics</a> in the Rust language can abstract the same set of logic for different types. More features of generics will be used in subsequent code.</p>
<p>After defining <code>ParseProto</code>, let's look at the syntax analysis process. We currently only support the statement of <code>print &quot;hello, world!&quot;</code>, which is the format of <code>Name String</code>. The Name is first read from the lexer, followed by the string constant. If it is not in this format, an error will be reported. The specific code is as follows:</p>
<pre><code class="language-rust  ignore">pub fn load(input: File) -&gt; ParseProto {
    let mut constants = Vec::new();
    let mut byte_codes = Vec::new();
    let mut lex = Lex::new(input);

    loop {
        match lex.next() {
            Token::Name(name) =&gt; { // `Name LiteralString` as function call
                constants.push(Value::String(name));
                byte_codes.push(ByteCode::GetGlobal(0, (constants.len()-1) as u8));

                if let Token::String(s) = lex.next() {
                    constants.push(Value::String(s));
                    byte_codes.push(ByteCode::LoadConst(1, (constants.len()-1) as u8));
                    byte_codes.push(ByteCode::Call(0, 1));
                } else {
                    panic!(&quot;expected string&quot;);
                }
            }
            Token::Eos =&gt; break,
            t =&gt; panic!(&quot;unexpected token: {t:?}&quot;),
        }
    }

    dbg!(&amp;constants);
    dbg!(&amp;byte_codes);
    ParseProto { constants, byte_codes }
}</code></pre>
<p>The input is the source file <code>File</code>, and the output is the <code>ParseProto</code> just defined.</p>
<p>The main body of the function is a loop, and the Token is cyclically read through the <code>next()</code> function provided by the lexical analyzer <code>lex</code> created at the beginning of the function. We currently only support one type of statement, <code>Name LiteralString</code>, and the semantics are function calls. So the analysis logic is also very simple:</p>
<ul>
<li>When <code>Name</code> is encountered, it is considered to be the beginning of a statement:
<ul>
<li>Use <code>Name</code> as a global variable and store it in the constant table;</li>
<li>Generate <code>GetGlobal</code> bytecode, load the global variable on the stack according to the name. The first parameter is the index of the target stack. Since we currently only support the function call statement, the stack is only used for function calls, so the function must be at position 0; the second parameter is the index of the global variable name in the global variable;</li>
<li>Read the next Token, and it is expected to be a string constant, otherwise panic;</li>
<li>Add string constants to the constant table;</li>
<li>Generate <code>LoadConst</code> bytecode to load constants onto the stack. The first parameter is the target stack index, which is behind the function and is 1; the second parameter is the index of the constant in the constant table;</li>
<li>Once the function and parameters are ready, <code>Call</code> bytecode can be generated to call the function. At present, the two parameters are the function position and the number of parameters, which are fixed at 0 and 1 respectively.</li>
</ul>
</li>
<li>When <code>Eos</code> is encountered, exit the loop.</li>
<li>When encountering other Tokens (currently only of <code>Token::String</code> type), panic.</li>
</ul>
<p>After the function, the constant table and bytecode sequence are output through <code>dbg!</code> for debugging. It can be compared with the output of <code>luac</code>.</p>
<p>Finally returns <code>ParseProto</code>.</p>
<h2 id="virtual-machine-execution"><a class="header" href="#virtual-machine-execution">Virtual Machine Execution</a></h2>
<p>After parsing and generating <code>ParseProto</code>, it is the turn of the virtual machine to execute. According to the previous analysis, the virtual machine currently requires two components: the stack and the global variable table. So define the virtual machine state as follows:</p>
<pre><code class="language-rust  ignore">pub struct ExeState {
    globals: HashMap&lt;String, Value&gt;,
    stack: Vec::&lt;Value&gt;,
}</code></pre>
<p>When creating a virtual machine, you need to add the <code>print</code> function in the global variable table in advance:</p>
<pre><code class="language-rust  ignore">impl ExeState {
    pub fn new() -&gt; Self {
        let mut globals = HashMap::new();
        globals.insert(String::from(&quot;print&quot;), Value::Function(lib_print));

        ExeState {
            globals,
            stack: Vec::new(),
        }
    }</code></pre>
<p>The <code>print</code> function is defined as follows:</p>
<pre><code class="language-rust  ignore">// &quot;print&quot; function in Lua's std-lib.
// It supports only 1 argument and assumes the argument is at index:1 on stack.
fn lib_print(state: &amp;mut ExeState) -&gt; i32 {
    println!(&quot;{:?}&quot;, state.stack[1]);
    0
}</code></pre>
<p>Currently the <code>print</code> function only supports one parameter, and it is assumed that this parameter is at position 1 of the stack. The function prints this parameter. Because this function does not need to return data to the caller, it returns 0.</p>
<p>After the initialization is completed, the following is the core virtual machine execution function, that is, the big bytecode dispatching loop: read the bytecode sequence in turn and execute the corresponding predefined subrotines. The specific code is as follows:</p>
<pre><code class="language-rust  ignore">    pub fn execute(&amp;mut self, proto: &amp;ParseProto) {
        for code in proto.byte_codes.iter() {
            match *code {
                ByteCode::GetGlobal(dst, name) =&gt; {
                    let name = &amp;proto.constants[name as usize];
                    if let Value::String(key) = name {
                        let v = self.globals.get(key).unwrap_or(&amp;Value::Nil).clone();
                        self.set_stack(dst, v);
                    } else {
                        panic!(&quot;invalid global key: {name:?}&quot;);
                    }
                }
                ByteCode::LoadConst(dst, c) =&gt; {
                    let v = proto.constants[c as usize].clone();
                    self.set_stack(dst, v);
                }
                ByteCode::Call(func, _) =&gt; {
                    let func = &amp;self.stack[func as usize];
                    if let Value::Function(f) = func {
                        f(self);
                    } else {
                        panic!(&quot;invalid function: {func:?}&quot;);
                    }
                }
            }
        }
    }</code></pre>
<p>Currently only 3 bytecodes are supported. All subrotines are clear, needless to explain.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>So far, we have implemented a Lua interpreter with a complete process! Look at the running effect:</p>
<pre><code>$ cargo r -q --test_lua/hello.lua
[src/parse.rs:39] &amp;constants = [
     print,
     hello, world!,
]
[src/parse.rs:40] &amp;byte_codes = [
     GetGlobal(
         0,
         0,
     ),
     LoadConst(
         1,
         1,
     ),
     Call(
         0,
     ),
]
hello world!
</code></pre>
<p>The output is divided into 3 parts. Part 1 is the constant table, containing 2 string constants. The second part is the bytecode sequence, which can be compared with the output of <code>luac</code> in the <a href="./ch01-02.byte_codes.html">Bytecode</a> section. The last line is the result we expected: &quot;hello, world!&quot;.</p>
<p>There is an additional function. The parsing part does not support only one line statement, but a loop. So we can support multiple <code>print</code> statements, such as:</p>
<pre><code class="language-lua">print &quot;hello, world!&quot;
print &quot;hello, again...&quot;
</code></pre>
<p>There is a small problem which is <code>print</code> appears twice in the constant table. It can be optimized here that every time adding a value to the constant table, check whether it already exists first. We will finish this in the next chapter.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The purpose of this chapter is to implement a minimal Lua interpreter but with complete process, in order to get familiar with the interpreter architecture. To this end, we first introduced the basics of compiling principles, then introduced the two core concepts of Lua's bytecode and value, and finally accomplished it!</p>
<p>We have been emphasizing the &quot;complete process&quot; because we only need to add features onto this framework in the following chapters. Let's move on!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01-03.value_and_type.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch02-00.variables.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01-03.value_and_type.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch02-00.variables.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
